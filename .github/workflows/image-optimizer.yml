# æ–‡ä»¶è·¯å¾„: .github/workflows/image-optimizer.yml

name: 'ğŸ¤– Optimize Bundle Images with ShortPixel'

on:
  push:
    branches:
      - main
    paths:
      - 'content/**/*.jpg'
      - 'content/**/*.png'
      - 'content/**/*.jpeg'
      - 'content/**/*.avif'
  
  schedule:
    - cron: '0 0 * * *'
    
  workflow_dispatch:

jobs:
  build:
    name: Convert Images Job
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      
    if: github.event.pusher.name != 'GitHub Actions Bot' && github.event.pusher.name != 'github-actions[bot]'

    steps:
      - name: 'â¬‡ï¸ Checkout Code'
        uses: actions/checkout@v4

      - name: 'ğŸ”§ Install Dependencies'
        run: sudo apt-get update && sudo apt-get install -y imagemagick jq

      - name: 'ğŸ”„ Find Images to Process'
        id: find_files
        run: |
          echo "ğŸ” Finding images that need conversion..."
          FILE_LIST=$(
            find content -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" \) | while read -r f; do
              # æ£€æŸ¥æ˜¯å¦å­˜åœ¨ä»»ä½•å¯¹åº”çš„ AVIF æ–‡ä»¶
              base_path="${f%.*}"
              has_avif=false
              
              # è·å–åŸå›¾å°ºå¯¸æ¥åˆ¤æ–­åº”è¯¥ç”Ÿæˆå“ªäº›å°ºå¯¸
              dimensions=$(identify -format "%wx%h" "$f" 2>/dev/null || echo "0x0")
              width=$(echo "$dimensions" | cut -d'x' -f1)
              
              # å®šä¹‰éœ€è¦çš„å°ºå¯¸
              sizes="480 960 1200 1920 2560 3840"
              
              # æ£€æŸ¥åŸå›¾æœ¬èº«çš„ AVIFï¼ˆåªæœ‰å®½åº¦<=3840çš„æ‰éœ€è¦åŸå›¾AVIFï¼‰
              if [ "$width" -le 3840 ] && [ ! -f "${base_path}.avif" ]; then
                echo "$f"
                continue
              fi
              
              # æ£€æŸ¥å„ä¸ªå°ºå¯¸çš„ AVIF
              for size in $sizes; do
                if [ "$width" -gt "$size" ] && [ ! -f "${base_path}_${size}w.avif" ]; then
                  echo "$f"
                  break
                fi
              done
            done | sort -u
          )
          UNCONVERTED_FILES=$(echo $FILE_LIST)
          if [ -n "$UNCONVERTED_FILES" ]; then
            echo "  - Found $(echo $UNCONVERTED_FILES | wc -w) images needing processing."
            echo "files_to_process=${UNCONVERTED_FILES}" >> $GITHUB_OUTPUT
          else
            echo "âœ… No images to process."
            echo "files_to_process=" >> $GITHUB_OUTPUT
          fi

      - name: 'ğŸ§¹ Clean up orphaned dimensions'
        run: |
          echo "ğŸ§¹ Cleaning up orphaned dimension entries..."
          find content -name ".image_dimensions.yaml" | while read -r yaml_file; do
            if [ -f "$yaml_file" ]; then
              dir_path=$(dirname "$yaml_file")
              temp_file=$(mktemp)
              while IFS=': ' read -r base_name dimensions; do
                # æ£€æŸ¥æ˜¯å¦å­˜åœ¨å¯¹åº”çš„ AVIF æ–‡ä»¶ï¼ˆåŸå›¾æˆ–ä»»ä½•å°ºå¯¸ï¼‰
                if [ -f "$dir_path/$base_name.avif" ] || ls "$dir_path/${base_name}_"*"w.avif" >/dev/null 2>&1; then
                  echo "$base_name: $dimensions" >> "$temp_file"
                fi
              done < "$yaml_file"
              mv "$temp_file" "$yaml_file"
              
              # å¦‚æœæ–‡ä»¶ä¸ºç©ºåˆ™åˆ é™¤
              if [ ! -s "$yaml_file" ]; then
                rm "$yaml_file"
              fi
            fi
          done
          
      - name: 'ğŸš€ Process Images with ShortPixel'
        if: steps.find_files.outputs.files_to_process != ''
        env:
          SHORTPIXEL_KEY: ${{ secrets.SHORTPIXEL_KEY }}
          FILES_TO_PROCESS: ${{ steps.find_files.outputs.files_to_process }}
          MAX_ATTEMPTS: 5
          POLL_INTERVAL_SECONDS: 30
        run: |
          # ä¸ºæ¯ä¸ªå›¾ç‰‡ç”Ÿæˆå¤šä¸ªå°ºå¯¸çš„ URL å’Œå‚æ•°
          declare -a url_list
          declare -a param_list
          declare -a file_mapping
          declare -A file_dimensions
          
          # é¦–å…ˆè·å–æ‰€æœ‰æ–‡ä»¶çš„å°ºå¯¸ä¿¡æ¯
          for file_path in $FILES_TO_PROCESS; do
            dimensions=$(identify -format "%wx%h" "$file_path")
            file_dimensions["$file_path"]="$dimensions"
            echo "ğŸ“ Processing $file_path ($dimensions)"
          done
          
          for file_path in $FILES_TO_PROCESS; do
            base_url="https://raw.githubusercontent.com/${{ github.repository }}/${{ github.sha }}/$file_path"
            
            # ä»ç¼“å­˜çš„å°ºå¯¸ä¿¡æ¯è·å–
            dimensions="${file_dimensions[$file_path]}"
            width=$(echo "$dimensions" | cut -d'x' -f1)
            height=$(echo "$dimensions" | cut -d'x' -f2)
            
            # å®šä¹‰éœ€è¦ç”Ÿæˆçš„å°ºå¯¸
            sizes="480 960 1200 1920 2560 3840"
            
            # æ·»åŠ åŸå›¾å¤„ç†ï¼ˆåªæœ‰å®½åº¦<=3840ä¸”ä¸å­˜åœ¨å¯¹åº”AVIFçš„æ‰å¤„ç†ï¼‰
            base_path="${file_path%.*}"
            if [ "$width" -le 3840 ] && [ ! -f "${base_path}.avif" ]; then
              url_list+=("$base_url")
              param_list+=('{
                "resize": 0,
                "convertto": "avif"
              }')
              file_mapping+=("$file_path:original")
              echo "  - Will generate original size AVIF (${width}x${height})"
            elif [ "$width" -gt 3840 ]; then
              echo "  - Skipping original size AVIF (${width}x${height} > 3840w limit)"
            fi
            
            # æ·»åŠ å„ä¸ªå°ºå¯¸çš„å¤„ç†
            for target_width in $sizes; do
              if [ "$width" -gt "$target_width" ] && [ ! -f "${base_path}_${target_width}w.avif" ]; then
                # è®¡ç®—å¯¹åº”çš„é«˜åº¦ï¼Œä¿æŒå®½é«˜æ¯”
                target_height=$((height * target_width / width))
                
                url_list+=("$base_url")
                param_list+=('{
                  "resize": 3,
                  "resize_width": '$target_width',
                  "resize_height": '$target_height',
                  "convertto": "avif"
                }')
                file_mapping+=("$file_path:${target_width}w")
                echo "  - Will generate ${target_width}w version (${target_width}x${target_height})"
              fi
            done
          done
          
          if [ ${#url_list[@]} -eq 0 ]; then
            echo "âœ… All images are already processed!"
            exit 0
          fi
          
          echo "ğŸ“Š Total conversions to process: ${#url_list[@]}"
          
          # å°†æ•°ç»„è½¬æ¢ä¸º JSON
          url_json=$(printf '%s\n' "${url_list[@]}" | jq -R . | jq -s .)
          param_json=$(printf '%s\n' "${param_list[@]}" | jq -s .)
          
          # ç”¨äºè·Ÿè¸ªå·²å¤„ç†çš„åŸå§‹æ–‡ä»¶
          declare -A processed_originals
          
          # åˆ†æ‰¹å¤„ç†ï¼ˆShortPixel API é™åˆ¶æ¯æ¬¡æœ€å¤š 100 ä¸ª URLï¼‰
          batch_size=50
          total_urls=${#url_list[@]}
          
          for ((i=0; i<total_urls; i+=batch_size)); do
            end=$((i + batch_size - 1))
            if [ $end -ge $total_urls ]; then
              end=$((total_urls - 1))
            fi
            
            echo -e "\nğŸ”„ Processing batch $((i/batch_size + 1)): URLs $((i+1)) to $((end+1))"
            
            # åˆ›å»ºå½“å‰æ‰¹æ¬¡çš„ URL å’Œå‚æ•°
            batch_urls=$(echo "$url_json" | jq ".[$i:$((end+1))]")
            batch_params=$(echo "$param_json" | jq ".[$i:$((end+1))]")
            
            for attempt in $(seq 1 $MAX_ATTEMPTS); do
              if [ "$(echo "$batch_urls" | jq 'length')" -eq 0 ]; then
                break
              fi
              
              echo "  Attempt $attempt/$MAX_ATTEMPTS for current batch"
              
              JSON_PAYLOAD=$(jq -n \
                --arg key "$SHORTPIXEL_KEY" \
                --argjson urls "$batch_urls" \
                --argjson params "$batch_params" \
                '{
                  key: $key,
                  plugin_version: "GHA45",
                  lossy: 2,
                  wait: 30,
                  urllist: $urls,
                  paramlist: $params
                }')
              
              API_RESPONSE=$(curl -s -X POST -H "Content-Type: application/json" -d "$JSON_PAYLOAD" https://api.shortpixel.com/v2/reducer.php)
              
              # å¤„ç†æˆåŠŸçš„è½¬æ¢
              echo "$API_RESPONSE" | jq -c '.[] | select(.Status.Code == "2")' | while read -r item; do
                original_url=$(echo "$item" | jq -r .OriginalURL)
                avif_url=$(echo "$item" | jq -r '.AVIFLossyURL // empty')
                
                # æŸ¥æ‰¾å¯¹åº”çš„æ–‡ä»¶æ˜ å°„
                for ((j=0; j<${#url_list[@]}; j++)); do
                  if [ "${url_list[j]}" = "$original_url" ]; then
                    mapping="${file_mapping[j]}"
                    original_file_path=$(echo "$mapping" | cut -d':' -f1)
                    size_suffix=$(echo "$mapping" | cut -d':' -f2)
                    
                    if [ -n "$avif_url" ] && [ "$avif_url" != "null" ] && [ "$avif_url" != "NA" ]; then
                      dir_path=$(dirname "$original_file_path")
                      base_name=$(basename "$original_file_path" | sed 's/\.[^.]*$//')
                      
                      if [ "$size_suffix" = "original" ]; then
                        avif_path="$dir_path/$base_name.avif"
                        echo "    - âœ… Downloaded original AVIF: $base_name.avif"
                      else
                        avif_path="$dir_path/${base_name}_${size_suffix}.avif"
                        echo "    - âœ… Downloaded resized AVIF: ${base_name}_${size_suffix}.avif"
                      fi
                      
                      curl -fsS --retry 3 -o "$avif_path" "$avif_url"
                      
                      # è®°å½•å·²å¤„ç†çš„åŸå›¾ï¼ˆä½†å…ˆä¸åˆ é™¤ï¼‰
                      if [ "$size_suffix" = "original" ] && [ -s "$avif_path" ]; then
                        dimensions="${file_dimensions[$original_file_path]}"
                        yaml_file="$dir_path/.image_dimensions.yaml"
                        touch "$yaml_file"
                        grep -q "${base_name}:" "$yaml_file" && sed -i "s|${base_name}:.*|${base_name}: ${dimensions}|" "$yaml_file" || echo "${base_name}: ${dimensions}" >> "$yaml_file"
                        processed_originals["$original_file_path"]=1
                      fi
                    fi
                    break
                  fi
                done
              done
              
              # æ›´æ–°å¾…å¤„ç†çš„æ‰¹æ¬¡
              next_batch_urls=$(echo "$API_RESPONSE" | jq '[.[] | select(.Status.Code != "2" or (.AVIFLossyURL == null or .AVIFLossyURL == "NA" or .AVIFLossyURL == "")) | .OriginalURL]')
              batch_urls="$next_batch_urls"
              
              if [ "$(echo "$batch_urls" | jq 'length')" -eq 0 ]; then
                break
              fi
              
              if [ "$attempt" -lt "$MAX_ATTEMPTS" ]; then
                echo "    Waiting ${POLL_INTERVAL_SECONDS}s before retry..."
                sleep $POLL_INTERVAL_SECONDS
              fi
            done
          done
          
          # å¤„ç†å®Œæ‰€æœ‰æ‰¹æ¬¡åï¼Œåˆ é™¤æˆåŠŸè½¬æ¢çš„åŸå§‹æ–‡ä»¶
          echo -e "\nğŸ—‘ï¸ Cleaning up successfully processed original files..."
          for original_file in "${!processed_originals[@]}"; do
            if [ -f "$original_file" ]; then
              rm "$original_file"
              echo "  - Removed: $original_file"
            fi
          done
          
          # å¯¹äºè¶…è¿‡3840å®½åº¦çš„å›¾ç‰‡ï¼Œå¦‚æœç”Ÿæˆäº†ç¼©ç•¥å›¾å°±åˆ é™¤åŸæ–‡ä»¶
          echo -e "\nğŸ—‘ï¸ Cleaning up large source images with generated thumbnails..."
          for file_path in $FILES_TO_PROCESS; do
            dimensions="${file_dimensions[$file_path]}"
            width=$(echo "$dimensions" | cut -d'x' -f1)
            
            if [ "$width" -gt 3840 ] && [ -f "$file_path" ]; then
              base_path="${file_path%.*}"
              # æ£€æŸ¥æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªç¼©ç•¥å›¾è¢«ç”Ÿæˆ
              if ls "${base_path}_"*"w.avif" >/dev/null 2>&1; then
                # è®°å½•åŸå›¾å°ºå¯¸åˆ°yamlæ–‡ä»¶
                dir_path=$(dirname "$file_path")
                base_name=$(basename "$file_path" | sed 's/\.[^.]*$//')
                yaml_file="$dir_path/.image_dimensions.yaml"
                touch "$yaml_file"
                grep -q "${base_name}:" "$yaml_file" && sed -i "s|${base_name}:.*|${base_name}: ${dimensions}|" "$yaml_file" || echo "${base_name}: ${dimensions}" >> "$yaml_file"
                
                rm "$file_path"
                echo "  - Removed large source image: $file_path (${dimensions})"
              fi
            fi
          done

      - name: 'ğŸš€ Commit and Push Changes'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: 'build(media): Convert images to multi-size AVIF'
          commit_author: ${{ github.actor }} <${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com>
