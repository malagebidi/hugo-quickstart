name: 'ü§ñ Optimize Bundle Images with ShortPixel'
on:
  push:
    branches:
      - main
    paths:
      - 'content/**/*.jpg'
      - 'content/**/*.png'
      - 'content/**/*.jpeg'

  schedule:
    - cron: '0 0 * * *'
    
  workflow_dispatch:

jobs:
  build:
    name: Convert Images Job
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      
    if: github.event.pusher.name != 'GitHub Actions Bot' && github.event.pusher.name != 'github-actions[bot]'
    steps:
      - name: '‚¨áÔ∏è Checkout Code'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 'üîÑ Pull Latest Changes'
        run: |
          git config --global user.name 'GitHub Actions Bot'
          git config --global user.email 'actions@github.com'
          git pull origin main --rebase || true

      - name: 'üîß Install Dependencies'
        # We only need jq now, as 'file' is pre-installed.
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: 'üîÑ Find Images to Process'
        id: find_files
        run: |
          echo "üîç Finding images that need conversion..."
          FILES_TO_PROCESS=""
          
          # Use a more robust 'while read' loop to handle file paths
          while IFS= read -r -d '' file; do
            base_path="${file%.*}"
            
            # Use 'file' command to get dimensions - a lightweight alternative
            dimensions_str=$(file "$file" | grep -oP '\d{2,}\s*x\s*\d{2,}' || true)
            if [[ -z "$dimensions_str" ]]; then
                echo "‚ö†Ô∏è Could not determine dimensions for $file. Skipping."
                continue
            fi

            # In some cases, `file` might output multiple dimensions. We take the first one.
            dimensions=$(echo "$dimensions_str" | head -n 1 | tr -d ' ')
            width=$(echo "$dimensions" | cut -d'x' -f1)
            height=$(echo "$dimensions" | cut -d'x' -f2)
            
            # Check if processing is needed
            needs_processing=false
            
            # Define required sizes
            sizes="480 720 960 1440 1920 2880 3840"
            
            # Check for original AVIF (only if width <= 3840)
            if [ "$width" -le 3840 ] && [ ! -f "${base_path}.avif" ]; then
              needs_processing=true
            fi
            
            # Check for resized AVIFs
            if [ "$needs_processing" = "false" ]; then
              for size in $sizes; do
                if [ "$width" -gt "$size" ] && [ ! -f "${base_path}_${size}w.avif" ]; then
                  needs_processing=true
                  break
                fi
              done
            fi
            
            if [ "$needs_processing" = "true" ]; then
              FILES_TO_PROCESS="$FILES_TO_PROCESS $file"
            fi
          done < <(find content -type f \( -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" \) -print0)
          
          # Output the results
          if [ -n "$FILES_TO_PROCESS" ]; then
            echo "files_to_process=$FILES_TO_PROCESS" >> $GITHUB_OUTPUT
            echo "  - Found $(echo $FILES_TO_PROCESS | wc -w) images needing processing."
          else
            echo "files_to_process=" >> $GITHUB_OUTPUT
            echo "‚úÖ No images to process."
          fi

      - name: 'üöÄ Process Images with ShortPixel'
        if: steps.find_files.outputs.files_to_process != ''
        env:
          SHORTPIXEL_KEY: ${{ secrets.SHORTPIXEL_KEY }}
          FILES_TO_PROCESS: ${{ steps.find_files.outputs.files_to_process }}
          MAX_ATTEMPTS: 3
          POLL_INTERVAL_SECONDS: 30
        run: |
          declare -A processed_originals
          declare -A file_dimensions
          
          # First, get dimensions for all files to be processed
          for file_path in $FILES_TO_PROCESS; do
            if [ -f "$file_path" ]; then
              # Use 'file' command - a lightweight alternative to imagemagick
              dimensions_str=$(file "$file_path" | grep -oP '\d{2,}x\d{2,}')
              if [[ -z "$dimensions_str" ]]; then
                  echo "‚ö†Ô∏è Could not determine dimensions for $file_path during processing. Skipping."
                  continue
              fi
              dimensions=$(echo "$dimensions_str" | head -n 1 | tr -d ' ')
              file_dimensions["$file_path"]="$dimensions"
              echo "üìè Identified $file_path ($dimensions)"
            fi
          done
          
          # Process each file
          for file_path in $FILES_TO_PROCESS; do
            if [ ! -f "$file_path" ]; then
              echo "‚ö†Ô∏è File not found during processing: $file_path"
              continue
            fi
            
            echo -e "\nüîÑ Processing: $file_path"
            base_url="https://raw.githubusercontent.com/${{ github.repository }}/${{ github.sha }}/$file_path"
            base_path="${file_path%.*}"
            
            dimensions="${file_dimensions[$file_path]}"
            if [[ -z "$dimensions" ]]; then
                echo "‚ö†Ô∏è Dimensions not found for $file_path. Skipping."
                continue
            fi

            width=$(echo "$dimensions" | cut -d'x' -f1)
            height=$(echo "$dimensions" | cut -d'x' -f2)
            
            echo "  Original dimensions: ${width}x${height}"
            
            sizes="480 720 960 1440 1920 2880 3840"
            
            # Process original size image (if width <= 3840)
            if [ "$width" -le 3840 ] && [ ! -f "${base_path}.avif" ]; then
              echo "  - Will generate original size AVIF (${width}x${height})"
              
              # ... [API call logic remains the same] ...
              success=false
              for attempt in $(seq 1 $MAX_ATTEMPTS); do
                # ... API call ...
                JSON_PAYLOAD='{ "key": "'$SHORTPIXEL_KEY'", "plugin_version": "GHA45", "lossy": 2, "wait": 20, "urllist": ["'$base_url'"], "paramlist": [{"resize": 0, "convertto": "avif"}] }'
                API_RESPONSE=$(curl -s -X POST -H "Content-Type: application/json" -d "$JSON_PAYLOAD" https://api.shortpixel.com/v2/reducer.php)
                if [ -n "$API_RESPONSE" ] && echo "$API_RESPONSE" | jq empty 2>/dev/null; then
                  status_code=$(echo "$API_RESPONSE" | jq -r '.[0].Status.Code // empty'); avif_url=$(echo "$API_RESPONSE" | jq -r '.[0].AVIFLossyURL // empty')
                  if [ "$status_code" = "2" ] && [ -n "$avif_url" ] && [ "$avif_url" != "null" ] && [ "$avif_url" != "NA" ]; then
                    if curl -fsS --retry 2 -o "${base_path}.avif" "$avif_url"; then
                      echo "      ‚úÖ Successfully generated: $(basename "${base_path}.avif")"; processed_originals["$file_path"]=1; success=true; break
                    else echo "      ‚ùå Failed to download from: $avif_url"; fi
                  else echo "      ‚ùå API failed with status: $status_code"; if [ -n "$API_RESPONSE" ]; then echo "      Error: $(echo "$API_RESPONSE" | jq -r '.[0].Status.Message // "Unknown error"') fi; fi
                else echo "      ‚ùå Invalid API response"; fi
                if [ "$attempt" -lt "$MAX_ATTEMPTS" ]; then echo "      Waiting ${POLL_INTERVAL_SECONDS}s before retry..."; sleep $POLL_INTERVAL_SECONDS; fi
              done
              if [ "$success" != "true" ]; then echo "      ‚ö†Ô∏è Failed to generate original after $MAX_ATTEMPTS attempts"; fi
            elif [ "$width" -gt 3840 ]; then
              echo "  - Skipping original size AVIF (${width}x${height} > 3840w limit)"
            fi
            
            # Process resized versions
            for target_width in $sizes; do
              if [ "$width" -gt "$target_width" ] && [ ! -f "${base_path}_${target_width}w.avif" ]; then
                target_height=$((height * target_width / width))
                echo "  - Will generate ${target_width}w version (${target_width}x${target_height})"
                
                # ... [API call logic remains the same] ...
                success=false
                for attempt in $(seq 1 $MAX_ATTEMPTS); do
                  # ... API Call ...
                  JSON_PAYLOAD='{ "key": "'$SHORTPIXEL_KEY'", "plugin_version": "GHA45", "lossy": 2, "wait": 20, "urllist": ["'$base_url'"], "paramlist": [{"resize": 3, "resize_width": '$target_width', "resize_height": '$target_height', "convertto": "avif"}] }'
                  API_RESPONSE=$(curl -s -X POST -H "Content-Type: application/json" -d "$JSON_PAYLOAD" https://api.shortpixel.com/v2/reducer.php)
                  if [ -n "$API_RESPONSE" ] && echo "$API_RESPONSE" | jq empty 2>/dev/null; then
                    status_code=$(echo "$API_RESPONSE" | jq -r '.[0].Status.Code // empty'); avif_url=$(echo "$API_RESPONSE" | jq -r '.[0].AVIFLossyURL // empty')
                    if [ "$status_code" = "2" ] && [ -n "$avif_url" ] && [ "$avif_url" != "null" ] && [ "$avif_url" != "NA" ]; then
                      output_file="${base_path}_${target_width}w.avif"
                      if curl -fsS --retry 2 -o "$output_file" "$avif_url"; then
                        echo "      ‚úÖ Successfully generated: $(basename "$output_file")"; success=true; processed_originals["$file_path"]=1; break
                      else echo "      ‚ùå Failed to download from: $avif_url"; fi
                    else echo "      ‚ùå API failed with status: $status_code"; if [ -n "$API_RESPONSE" ]; then echo "      Error: $(echo "$API_RESPONSE" | jq -r '.[0].Status.Message // "Unknown error"') fi; fi
                  else echo "      ‚ùå Invalid API response"; fi
                  if [ "$attempt" -lt "$MAX_ATTEMPTS" ]; then echo "      Waiting ${POLL_INTERVAL_SECONDS}s before retry..."; sleep $POLL_INTERVAL_SECONDS; fi
                done
                if [ "$success" != "true" ]; then echo "      ‚ö†Ô∏è Failed to generate ${target_width}w after $MAX_ATTEMPTS attempts"; fi
              fi
            done
          done
          
          # Record dimensions for successfully processed files
          echo -e "\n‚úçÔ∏è Recording dimensions for processed files..."
          for original_file in "${!processed_originals[@]}"; do
            if [ -f "$original_file" ]; then
              dimensions="${file_dimensions[$original_file]}"
              dir_path=$(dirname "$original_file")
              base_name=$(basename "$original_file" | sed 's/\.[^.]*$//')
              yaml_file="$dir_path/.image_dimensions.yaml"
              touch "$yaml_file"
              if grep -qF "${base_name}:" "$yaml_file" 2>/dev/null; then
                sed -i "s|${base_name}:.*|${base_name}: ${dimensions}|" "$yaml_file"
              else
                echo "${base_name}: ${dimensions}" >> "$yaml_file"
              fi
              echo "  - ‚úÖ Recorded dimensions for: $(basename "$original_file") (${dimensions})"
            fi
          done

      - name: 'üßπ Clean up orphaned dimensions'
        run: |
          echo "üßπ Cleaning up orphaned dimension entries..."
          find content -name ".image_dimensions.yaml" 2>/dev/null | while read -r yaml_file; do
            if [ -f "$yaml_file" ]; then
              dir_path=$(dirname "$yaml_file")
              temp_file=$(mktemp)
              cleaned_count=0
              
              while IFS= read -r line || [[ -n "$line" ]]; do
                if [[ -z "$line" ]] || ! [[ "$line" =~ : ]]; then continue; fi
                base_name=$(echo "$line" | sed -e 's/:.*//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
                if [ -z "$base_name" ]; then continue; fi
                
                image_exists=false
                # Check if ANY image file (original or AVIF) exists for this basename
                if [ -f "$dir_path/$base_name.avif" ] || \
                   [ -f "$dir_path/$base_name.jpg" ] || \
                   [ -f "$dir_path/$base_name.jpeg" ] || \
                   [ -f "$dir_path/$base_name.png" ] || \
                   ls "$dir_path/${base_name}_"*"w.avif" >/dev/null 2>&1; then
                  image_exists=true
                fi
                
                if [ "$image_exists" = "true" ]; then
                  echo "$line" >> "$temp_file"
                else
                  echo "  - üóëÔ∏è Removed orphaned entry: $base_name"
                  cleaned_count=$((cleaned_count + 1))
                fi
              done < "$yaml_file"
              
              if [ -s "$temp_file" ]; then
                mv "$temp_file" "$yaml_file"
              else
                rm "$temp_file" "$yaml_file"
                echo "  - üóëÔ∏è Removed empty file: $(basename "$yaml_file")"
              fi
              
              if [ "$cleaned_count" -gt 0 ]; then
                echo "  - üìä Cleaned $cleaned_count entries from $(basename "$yaml_file")"
              fi
            fi
          done
      
      - name: 'üöÄ Commit and Push Changes'
        run: |
          git config --global user.name 'GitHub Actions Bot'
          git config --global user.email 'actions@github.com'
          
          git fetch origin
          git rebase origin/main || true
          
          echo "üîç Checking for changes..."
          git add content/
          
          if git diff --cached --quiet; then
            echo "üì≠ No changes to commit"
          else
            echo "‚úÖ Found changes, committing..."
            git commit -m "build(media): Generate multi-size AVIF images"
            git push --force-with-lease origin main
            echo "üöÄ Changes pushed successfully"
          fi

