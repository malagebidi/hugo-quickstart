# 文件路径: .github/workflows/image-optimizer.yml
name: '🤖 Optimize Bundle Images with ShortPixel'
on:
  push:
    branches:
      - main
    paths:
      - 'content/**/*.jpg'
      - 'content/**/*.png'
      - 'content/**/*.jpeg'
      - 'content/**/*.avif'
 
  schedule:
    - cron: '0 0 * * *'
    
  workflow_dispatch:
jobs:
  build:
    name: Convert Images Job
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      
    if: github.event.pusher.name != 'GitHub Actions Bot' && github.event.pusher.name != 'github-actions[bot]'
    steps:
      - name: '⬇️ Checkout Code'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: '🔄 Pull Latest Changes'
        run: |
          git config --global user.name 'GitHub Actions Bot'
          git config --global user.email 'actions@github.com'
          git pull origin main || true
      - name: '🔧 Install Dependencies'
        run: sudo apt-get update && sudo apt-get install -y imagemagick jq
      - name: '🔄 Find Images to Process'
        id: find_files
        run: |
          echo "🔍 Finding images that need conversion..."
          
          FILES_TO_PROCESS=""
          
          # 使用 for 循环代替 find 来避免语法错误
          for ext in jpg jpeg png; do
            for file in $(find content -type f -name "*.${ext}" 2>/dev/null || true); do
              if [ -f "$file" ]; then
                base_path="${file%.*}"
                
                # 获取原图尺寸
                dimensions=$(identify -format "%wx%h" "$file" 2>/dev/null || echo "0x0")
                width=$(echo "$dimensions" | cut -d'x' -f1)
                
                # 检查是否需要处理
                needs_processing=false
                
                # 定义需要的尺寸
                sizes="480 720 960 1440 1920 2880 3840"
                
                # 检查原图本身的 AVIF（只有宽度<=3840的才需要原图AVIF）
                if [ "$width" -le 3840 ] && [ ! -f "${base_path}.avif" ]; then
                  needs_processing=true
                fi
                
                # 检查各个尺寸的 AVIF
                if [ "$needs_processing" = "false" ]; then
                  for size in $sizes; do
                    if [ "$width" -gt "$size" ] && [ ! -f "${base_path}_${size}w.avif" ]; then
                      needs_processing=true
                      break
                    fi
                  done
                fi
                
                if [ "$needs_processing" = "true" ]; then
                  FILES_TO_PROCESS="$FILES_TO_PROCESS $file"
                fi
              fi
            done
          done
          
          # 输出结果
          if [ -n "$FILES_TO_PROCESS" ]; then
            echo "files_to_process=$FILES_TO_PROCESS" >> $GITHUB_OUTPUT
            echo "  - Found $(echo $FILES_TO_PROCESS | wc -w) images needing processing."
          else
            echo "files_to_process=" >> $GITHUB_OUTPUT
            echo "✅ No images to process."
          fi
      - name: '🚀 Process Images with ShortPixel'
        if: steps.find_files.outputs.files_to_process != ''
        env:
          SHORTPIXEL_KEY: ${{ secrets.SHORTPIXEL_KEY }}
          FILES_TO_PROCESS: ${{ steps.find_files.outputs.files_to_process }}
          MAX_ATTEMPTS: 3
          POLL_INTERVAL_SECONDS: 30
        run: |
          # 用于跟踪已处理的原始文件
          declare -A processed_originals
          declare -A file_dimensions
          declare -A removed_originals
          
          # 首先获取所有文件的尺寸信息
          for file_path in $FILES_TO_PROCESS; do
            if [ -f "$file_path" ]; then
              dimensions=$(identify -format "%wx%h" "$file_path")
              file_dimensions["$file_path"]="$dimensions"
              echo "📏 Processing $file_path ($dimensions)"
            fi
          done
          
          # 处理每个文件
          for file_path in $FILES_TO_PROCESS; do
            if [ ! -f "$file_path" ]; then
              echo "⚠️ File not found: $file_path"
              continue
            fi
            
            echo -e "\n🔄 Processing: $file_path"
            base_url="https://raw.githubusercontent.com/${{ github.repository }}/${{ github.sha }}/$file_path"
            base_path="${file_path%.*}"
            dir_path=$(dirname "$file_path")
            base_name=$(basename "$file_path" | sed 's/\.[^.]*$//')
            
            # 从缓存的尺寸信息获取
            dimensions="${file_dimensions[$file_path]}"
            width=$(echo "$dimensions" | cut -d'x' -f1)
            height=$(echo "$dimensions" | cut -d'x' -f2)
            
            echo "  Original dimensions: ${width}x${height}"
            
            # 定义需要生成的尺寸
            sizes="480 720 960 1440 1920 2880 3840"
            
            # 检查原图处理（只有宽度<=3840且不存在对应AVIF的才处理）
            if [ "$width" -le 3840 ] && [ ! -f "${base_path}.avif" ]; then
              echo "  - Will generate original size AVIF (${width}x${height})"
              
              # 处理原图
              echo "    Processing original..."
              success=false
              for attempt in $(seq 1 $MAX_ATTEMPTS); do
                echo "      Attempt $attempt/$MAX_ATTEMPTS"
                
                JSON_PAYLOAD='{
                  "key": "'$SHORTPIXEL_KEY'",
                  "plugin_version": "GHA45",
                  "lossy": 2,
                  "wait": 20,
                  "urllist": ["'$base_url'"],
                  "paramlist": [{
                    "resize": 0,
                    "convertto": "avif"
                  }]
                }'
                
                API_RESPONSE=$(curl -s -X POST -H "Content-Type: application/json" -d "$JSON_PAYLOAD" https://api.shortpixel.com/v2/reducer.php)
                
                if [ -n "$API_RESPONSE" ] && echo "$API_RESPONSE" | jq empty 2>/dev/null; then
                  status_code=$(echo "$API_RESPONSE" | jq -r '.[0].Status.Code // empty')
                  avif_url=$(echo "$API_RESPONSE" | jq -r '.[0].AVIFLossyURL // empty')
                  
                  if [ "$status_code" = "2" ] && [ -n "$avif_url" ] && [ "$avif_url" != "null" ] && [ "$avif_url" != "NA" ]; then
                    if curl -fsS --retry 2 -o "${base_path}.avif" "$avif_url"; then
                      echo "      ✅ Successfully generated: $(basename "${base_path}.avif")"
                      processed_originals["$file_path"]=1
                      success=true
                      break
                    else
                      echo "      ❌ Failed to download from: $avif_url"
                    fi
                  else
                    echo "      ❌ API failed with status: $status_code"
                    if [ -n "$API_RESPONSE" ]; then
                      echo "      Error: $(echo "$API_RESPONSE" | jq -r '.[0].Status.Message // "Unknown error"')"
                    fi
                  fi
                else
                  echo "      ❌ Invalid API response"
                fi
                
                if [ "$attempt" -lt "$MAX_ATTEMPTS" ]; then
                  echo "      Waiting ${POLL_INTERVAL_SECONDS}s before retry..."
                  sleep $POLL_INTERVAL_SECONDS
                fi
              done
              
              if [ "$success" != "true" ]; then
                echo "      ⚠️ Failed to generate original after $MAX_ATTEMPTS attempts"
              fi
            elif [ "$width" -gt 3840 ]; then
              echo "  - Skipping original size AVIF (${width}x${height} > 3840w limit)"
            fi
            
            # 处理各个尺寸
            for target_width in $sizes; do
              if [ "$width" -gt "$target_width" ] && [ ! -f "${base_path}_${target_width}w.avif" ]; then
                target_height=$((height * target_width / width))
                echo "  - Will generate ${target_width}w version (${target_width}x${target_height})"
                
                echo "    Processing ${target_width}w..."
                success=false
                for attempt in $(seq 1 $MAX_ATTEMPTS); do
                  echo "      Attempt $attempt/$MAX_ATTEMPTS"
                  
                  JSON_PAYLOAD='{
                    "key": "'$SHORTPIXEL_KEY'",
                    "plugin_version": "GHA45",
                    "lossy": 2,
                    "wait": 20,
                    "urllist": ["'$base_url'"],
                    "paramlist": [{
                      "resize": 3,
                      "resize_width": '$target_width',
                      "resize_height": '$target_height',
                      "convertto": "avif"
                    }]
                  }'
                  
                  API_RESPONSE=$(curl -s -X POST -H "Content-Type: application/json" -d "$JSON_PAYLOAD" https://api.shortpixel.com/v2/reducer.php)
                  
                  if [ -n "$API_RESPONSE" ] && echo "$API_RESPONSE" | jq empty 2>/dev/null; then
                    status_code=$(echo "$API_RESPONSE" | jq -r '.[0].Status.Code // empty')
                    avif_url=$(echo "$API_RESPONSE" | jq -r '.[0].AVIFLossyURL // empty')
                    
                    if [ "$status_code" = "2" ] && [ -n "$avif_url" ] && [ "$avif_url" != "null" ] && [ "$avif_url" != "NA" ]; then
                      output_file="${base_path}_${target_width}w.avif"
                      if curl -fsS --retry 2 -o "$output_file" "$avif_url"; then
                        echo "      ✅ Successfully generated: $(basename "$output_file")"
                        success=true
                        break
                      else
                        echo "      ❌ Failed to download from: $avif_url"
                      fi
                    else
                      echo "      ❌ API failed with status: $status_code"
                      if [ -n "$API_RESPONSE" ]; then
                        echo "      Error: $(echo "$API_RESPONSE" | jq -r '.[0].Status.Message // "Unknown error"')"
                      fi
                    fi
                  else
                    echo "      ❌ Invalid API response"
                  fi
                  
                  if [ "$attempt" -lt "$MAX_ATTEMPTS" ]; then
                    echo "      Waiting ${POLL_INTERVAL_SECONDS}s before retry..."
                    sleep $POLL_INTERVAL_SECONDS
                  fi
                done
                
                if [ "$success" != "true" ]; then
                  echo "      ⚠️ Failed to generate ${target_width}w after $MAX_ATTEMPTS attempts"
                fi
              fi
            done
          done
          
          # 统一处理所有成功转换的原始文件
          echo -e "\n🗑️ Cleaning up successfully processed original files..."
          for original_file in "${!processed_originals[@]}"; do
            if [ -f "$original_file" ]; then
              # 检查是否至少生成了一些AVIF文件
              base_path="${original_file%.*}"
              if [ -f "${base_path}.avif" ] || ls "${base_path}_"*"w.avif" >/dev/null 2>&1; then
                # 记录尺寸信息
                dimensions="${file_dimensions[$original_file]}"
                dir_path=$(dirname "$original_file")
                base_name=$(basename "$original_file" | sed 's/\.[^.]*$//')
                yaml_file="$dir_path/.image_dimensions.yaml"
                touch "$yaml_file"
                if grep -q "${base_name}:" "$yaml_file" 2>/dev/null; then
                  sed -i "s|${base_name}:.*|${base_name}: ${dimensions}|" "$yaml_file"
                else
                  echo "${base_name}: ${dimensions}" >> "$yaml_file"
                fi

                # 删除原始文件
                rm "$original_file"
                echo "  - ✅ Removed: $(basename "$original_file") (${dimensions})"
                removed_originals["${dir_path}/${base_name}"]="${dimensions}"
              else
                echo "  - ⚠️ No AVIF files found for: $(basename "$original_file"), keeping original"
              fi
            fi
          done
          
      - name: '🧹 Clean up orphaned dimensions'
        run: |
          echo "🧹 Cleaning up orphaned dimension entries..."
          find content -name ".image_dimensions.yaml" 2>/dev/null | while read -r yaml_file; do
            if [ -f "$yaml_file" ]; then
              dir_path=$(dirname "$yaml_file")
              temp_file=$(mktemp)
              cleaned_count=0
              
              # --- START OF FIX ---
              # 使用更健壮的循环来读取文件，确保能处理各种格式和没有结尾换行符的文件
              while IFS= read -r line || [[ -n "$line" ]]; do
                # 跳过空行或不包含冒号的无效行
                if [[ -z "$line" ]] || ! [[ "$line" =~ : ]]; then
                  continue
                fi

                # 健壮地解析 "key: value"
                # 提取冒号前的所有内容作为 base_name，并去除首尾空格
                base_name=$(echo "$line" | sed -e 's/:.*//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
                dimensions=$(echo "$line" | sed 's/.*:[[:space:]]*//')

                # 如果 base_name 为空，则跳过
                if [ -z "$base_name" ]; then
                  continue
                fi
              # --- END OF FIX ---

                # 检查是否存在对应的AVIF文件 (这部分逻辑是正确的)
                has_avif_files=false

                # 检查原始尺寸的AVIF
                if [ -f "$dir_path/$base_name.avif" ]; then
                  has_avif_files=true
                fi

                # 检查各种尺寸的AVIF
                if [ "$has_avif_files" = "false" ]; then
                  for size in 480 720 960 1440 1920 2880 3840; do
                    if [ -f "$dir_path/${base_name}_${size}w.avif" ]; then
                      has_avif_files=true
                      break
                    fi
                  done
                fi

                # 如果存在AVIF文件，保留维度信息
                if [ "$has_avif_files" = "true" ]; then
                  echo "$base_name: $dimensions" >> "$temp_file"
                else
                  echo "  - 🗑️ Removed orphaned entry: $base_name"
                  cleaned_count=$((cleaned_count + 1))
                fi
              done < "$yaml_file" # 读取原始文件

              # 替换原文件
              if [ -s "$temp_file" ]; then
                mv "$temp_file" "$yaml_file"
                echo "  - ✅ Updated: $(basename "$yaml_file")"
              else
                rm "$temp_file" "$yaml_file"
                echo "  - 🗑️ Removed empty: $(basename "$yaml_file")"
              fi

              if [ "$cleaned_count" -gt 0 ]; then
                echo "  - 📊 Cleaned $cleaned_count orphaned entries from $(basename "$yaml_file")"
              fi
            fi
          done
      
      - name: '🚀 Commit and Push Changes'
        run: |
          git config --global user.name 'GitHub Actions Bot'
          git config --global user.email 'actions@github.com'

          # 拉取最新更改
          git fetch origin
          git rebase origin/main || true
          
          echo "🔍 Checking for changes..."

          # 使用 'git add content/' 来暂存 'content' 目录下的所有变更，
          echo "📝 Staging all changes in the content directory..."
          git add content/

          # 检查是否有变更
          if git diff --cached --quiet; then
            echo "📭 No changes to commit"
          else
            echo "✅ Found changes, committing..."
            git commit -m "build(media): Convert images to multi-size AVIF"
            git push --force-with-lease origin main
            echo "🚀 Changes pushed successfully"
          fi
