# æ–‡ä»¶è·¯å¾„: .github/workflows/image-optimizer.yml

name: 'ğŸ¤– Optimize Bundle Images with ShortPixel'

on:
  push:
    branches:
      - main
    paths:
      - 'content/**/*.jpg'
      - 'content/**/*.png'
      - 'content/**/*.jpeg'
      - 'content/**/*.avif'

  schedule:
    - cron: '0 0 * * *'
  
  workflow_dispatch:

jobs:
  build:
    name: Convert Images Job
    runs-on: ubuntu-latest
  
    permissions:
      contents: write
    
    if: github.event.pusher.name != 'GitHub Actions Bot' && github.event.pusher.name != 'github-actions[bot]'

    steps:
      - name: 'â¬‡ï¸ Checkout Code'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 'ğŸ”„ Pull Latest Changes'
        run: |
          git config --global user.name 'GitHub Actions Bot'
          git config --global user.email 'actions@github.com'
          git pull origin main || true

      - name: 'ğŸ”§ Install Dependencies'
        run: sudo apt-get update && sudo apt-get install -y imagemagick jq

      - name: 'ğŸ”„ Find Images to Process'
        id: find_files
        run: |
          echo "ğŸ” Finding images that need conversion..."
        
          # åˆ›å»ºä¸´æ—¶æ–‡ä»¶åˆ—è¡¨
          TEMP_FILE=$(mktemp)
        
          # æŸ¥æ‰¾æ‰€æœ‰å›¾ç‰‡æ–‡ä»¶
          find content -type f \( -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" \) > "$TEMP_FILE"
        
          # æ£€æŸ¥æ¯ä¸ªæ–‡ä»¶æ˜¯å¦éœ€è¦å¤„ç†
          FILES_TO_PROCESS=""
          while IFS= read -r file_path; do
            if [ -f "$file_path" ]; then
              base_path="${file_path%.*}"
            
              # è·å–åŸå›¾å°ºå¯¸
              dimensions=$(identify -format "%wx%h" "$file_path" 2>/dev/null || echo "0x0")
              width=$(echo "$dimensions" | cut -d'x' -f1)
            
              # æ£€æŸ¥æ˜¯å¦éœ€è¦å¤„ç†
              needs_processing=false
            
              # å®šä¹‰éœ€è¦çš„å°ºå¯¸
              sizes="480 960 1200 1920 2560 3840"
            
              # æ£€æŸ¥åŸå›¾æœ¬èº«çš„ AVIFï¼ˆåªæœ‰å®½åº¦<=3840çš„æ‰éœ€è¦åŸå›¾AVIFï¼‰
              if [ "$width" -le 3840 ] && [ ! -f "${base_path}.avif" ]; then
                needs_processing=true
              fi
            
              # æ£€æŸ¥å„ä¸ªå°ºå¯¸çš„ AVIF
              if [ "$needs_processing" = "false" ]; then
                for size in $sizes; do
                  if [ "$width" -gt "$size" ] && [ ! -f "${base_path}_${size}w.avif" ]; then
                    needs_processing=true
                    break
                  fi
                done
              fi
            
              if [ "$needs_processing" = "true" ]; then
                FILES_TO_PROCESS="$FILES_TO_PROCESS $file_path"
              fi
            fi
          done < "$TEMP_FILE"
        
          rm "$TEMP_FILE"
        
          # è¾“å‡ºç»“æœ
          if [ -n "$FILES_TO_PROCESS" ]; then
            echo "files_to_process=$FILES_TO_PROCESS" >> $GITHUB_OUTPUT
            echo "  - Found $(echo $FILES_TO_PROCESS | wc -w) images needing processing."
          else
            echo "files_to_process=" >> $GITHUB_OUTPUT
            echo "âœ… No images to process."
          fi

      - name: 'ğŸ§¹ Clean up orphaned dimensions'
        run: |
          echo "ğŸ§¹ Cleaning up orphaned dimension entries..."
          find content -name ".image_dimensions.yaml" 2>/dev/null | while read -r yaml_file; do
            if [ -f "$yaml_file" ]; then
              dir_path=$(dirname "$yaml_file")
              temp_file=$(mktemp)
              while IFS=': ' read -r base_name dimensions; do
                # æ£€æŸ¥æ˜¯å¦å­˜åœ¨å¯¹åº”çš„ AVIF æ–‡ä»¶ï¼ˆåŸå›¾æˆ–ä»»ä½•å°ºå¯¸ï¼‰
                if [ -f "$dir_path/$base_name.avif" ] || ls "$dir_path/${base_name}_"*"w.avif" >/dev/null 2>&1; then
                  echo "$base_name: $dimensions" >> "$temp_file"
                fi
              done < "$yaml_file"
              mv "$temp_file" "$yaml_file"
            
              # å¦‚æœæ–‡ä»¶ä¸ºç©ºåˆ™åˆ é™¤
              if [ ! -s "$yaml_file" ]; then
                rm "$yaml_file"
              fi
            fi
          done
        
      - name: 'ğŸš€ Process Images with ShortPixel'
        if: steps.find_files.outputs.files_to_process != ''
        env:
          SHORTPIXEL_KEY: ${{ secrets.SHORTPIXEL_KEY }}
          FILES_TO_PROCESS: ${{ steps.find_files.outputs.files_to_process }}
          MAX_ATTEMPTS: 3
          POLL_INTERVAL_SECONDS: 20
        run: |
          # ç”¨äºè·Ÿè¸ªå·²å¤„ç†çš„åŸå§‹æ–‡ä»¶
          declare -A processed_originals
          declare -A file_dimensions
        
          # é¦–å…ˆè·å–æ‰€æœ‰æ–‡ä»¶çš„å°ºå¯¸ä¿¡æ¯
          for file_path in $FILES_TO_PROCESS; do
            if [ -f "$file_path" ]; then
              dimensions=$(identify -format "%wx%h" "$file_path")
              file_dimensions["$file_path"]="$dimensions"
              echo "ğŸ“ Processing $file_path ($dimensions)"
            fi
          done
        
          # å¤„ç†æ¯ä¸ªæ–‡ä»¶
          for file_path in $FILES_TO_PROCESS; do
            if [ ! -f "$file_path" ]; then
              echo "âš ï¸ File not found: $file_path"
              continue
            fi
          
            echo -e "\nğŸ”„ Processing: $file_path"
            base_url="https://raw.githubusercontent.com/${{ github.repository }}/${{ github.sha }}/$file_path"
            base_path="${file_path%.*}"
            dir_path=$(dirname "$file_path")
            base_name=$(basename "$file_path" | sed 's/\.[^.]*$//')
          
            # ä»ç¼“å­˜çš„å°ºå¯¸ä¿¡æ¯è·å–
            dimensions="${file_dimensions[$file_path]}"
            width=$(echo "$dimensions" | cut -d'x' -f1)
            height=$(echo "$dimensions" | cut -d'x' -f2)
          
            # å®šä¹‰éœ€è¦ç”Ÿæˆçš„å°ºå¯¸
            sizes="480 960 1200 1920 2560 3840"
          
            # æ”¶é›†éœ€è¦å¤„ç†çš„ä»»åŠ¡
            declare -a tasks=()
          
            # æ£€æŸ¥åŸå›¾å¤„ç†ï¼ˆåªæœ‰å®½åº¦<=3840ä¸”ä¸å­˜åœ¨å¯¹åº”AVIFçš„æ‰å¤„ç†ï¼‰
            if [ "$width" -le 3840 ] && [ ! -f "${base_path}.avif" ]; then
              tasks+=("original:$base_url:0:0")
              echo "  - Will generate original size AVIF (${width}x${height})"
            elif [ "$width" -gt 3840 ]; then
              echo "  - Skipping original size AVIF (${width}x${height} > 3840w limit)"
            fi
          
            # æ£€æŸ¥å„ä¸ªå°ºå¯¸çš„å¤„ç†
            for target_width in $sizes; do
              if [ "$width" -gt "$target_width" ] && [ ! -f "${base_path}_${target_width}w.avif" ]; then
                target_height=$((height * target_width / width))
                tasks+=("${target_width}w:$base_url:$target_width:$target_height")
                echo "  - Will generate ${target_width}w version (${target_width}x${target_height})"
              fi
            done
          
            # é€ä¸ªå¤„ç†ä»»åŠ¡
            for task in "${tasks[@]}"; do
              IFS=':' read -r size_suffix url target_w target_h <<< "$task"
            
              echo "    Processing $size_suffix (target: ${target_w}x${target_h})..."
            
              # é‡è¯•æœºåˆ¶
              success=false
              for attempt in $(seq 1 $MAX_ATTEMPTS); do
                echo "      Attempt $attempt/$MAX_ATTEMPTS"
              
                # æ„å»ºAPI payload
                if [ "$size_suffix" = "original" ]; then
                  JSON_PAYLOAD='{
                    "key": "'$SHORTPIXEL_KEY'",
                    "plugin_version": "GHA45",
                    "lossy": 2,
                    "wait": 20,
                    "urllist": ["'$url'"],
                    "paramlist": [{
                      "resize": 0,
                      "convertto": "avif"
                    }]
                  }'
                  output_file="${base_path}.avif"
                else
                  # ç¡®ä¿å˜é‡ä¸ä¸ºç©ºä¸”ä¸ºæ•°å­—
                  if [[ ! "$target_w" =~ ^[0-9]+$ ]] || [[ ! "$target_h" =~ ^[0-9]+$ ]]; then
                    echo "      âŒ Invalid dimensions: ${target_w}x${target_h}"
                    break
                  fi
                
                  JSON_PAYLOAD='{
                    "key": "'$SHORTPIXEL_KEY'",
                    "plugin_version": "GHA45",
                    "lossy": 2,
                    "wait": 20,
                    "urllist": ["'$url'"],
                    "paramlist": [{
                      "resize": 3,
                      "resize_width": '$target_w',
                      "resize_height": '$target_h',
                      "convertto": "avif"
                    }]
                  }'
                  output_file="${base_path}_${size_suffix}.avif"
                fi
              
                # éªŒè¯ JSON æ ¼å¼
                if ! echo "$JSON_PAYLOAD" | jq empty 2>/dev/null; then
                  echo "      âŒ Invalid JSON payload"
                  break
                fi
              
                # è°ƒç”¨ API
                API_RESPONSE=$(curl -s -X POST -H "Content-Type: application/json" -d "$JSON_PAYLOAD" https://api.shortpixel.com/v2/reducer.php)
              
                # æ£€æŸ¥å“åº”
                if [ -z "$API_RESPONSE" ]; then
                  echo "      âŒ Empty API response"
                elif ! echo "$API_RESPONSE" | jq empty 2>/dev/null; then
                  echo "      âŒ Invalid JSON response: $API_RESPONSE"
                else
                  status_code=$(echo "$API_RESPONSE" | jq -r '.[0].Status.Code // empty')
                  avif_url=$(echo "$API_RESPONSE" | jq -r '.[0].AVIFLossyURL // empty')
                
                  if [ "$status_code" = "2" ] && [ -n "$avif_url" ] && [ "$avif_url" != "null" ] && [ "$avif_url" != "NA" ]; then
                    if curl -fsS --retry 2 -o "$output_file" "$avif_url"; then
                      echo "      âœ… Successfully generated: $(basename "$output_file")"
                      success=true
                    
                      # è®°å½•åŸå›¾å¤„ç†çŠ¶æ€
                      if [ "$size_suffix" = "original" ]; then
                        processed_originals["$file_path"]=1
                      fi
                      break
                    else
                      echo "      âŒ Failed to download from: $avif_url"
                    fi
                  else
                    echo "      âŒ API failed with status: $status_code"
                    if [ -n "$API_RESPONSE" ]; then
                      echo "      Error: $(echo "$API_RESPONSE" | jq -r '.[0].Status.Message // "Unknown error"')"
                    fi
                  fi
                fi
              
                if [ "$attempt" -lt "$MAX_ATTEMPTS" ]; then
                  echo "      Waiting ${POLL_INTERVAL_SECONDS}s before retry..."
                  sleep $POLL_INTERVAL_SECONDS
                fi
              done
            
              if [ "$success" != "true" ]; then
                echo "      âš ï¸ Failed to generate $size_suffix after $MAX_ATTEMPTS attempts"
              fi
            done
          
            # æ£€æŸ¥æ˜¯å¦è‡³å°‘ç”Ÿæˆäº†ä¸€äº›æ–‡ä»¶ï¼Œå¦‚æœæ˜¯å¤§å›¾åˆ™å¯ä»¥åˆ é™¤åŸæ–‡ä»¶
            if [ "$width" -gt 3840 ]; then
              if ls "${base_path}_"*"w.avif" >/dev/null 2>&1; then
                # è®°å½•åŸå›¾å°ºå¯¸åˆ°yamlæ–‡ä»¶
                yaml_file="$dir_path/.image_dimensions.yaml"
                touch "$yaml_file"
                if grep -q "${base_name}:" "$yaml_file" 2>/dev/null; then
                  sed -i "s|${base_name}:.*|${base_name}: ${dimensions}|" "$yaml_file"
                else
                  echo "${base_name}: ${dimensions}" >> "$yaml_file"
                fi
              
                rm "$file_path"
                echo "  ğŸ—‘ï¸ Removed large source image: $(basename "$file_path") (${dimensions})"
              fi
            fi
          done
        
          # å¤„ç†æˆåŠŸè½¬æ¢çš„åŸå§‹æ–‡ä»¶ï¼ˆ<=3840å®½åº¦çš„ï¼‰
          echo -e "\nğŸ—‘ï¸ Cleaning up successfully processed original files..."
          for original_file in "${!processed_originals[@]}"; do
            if [ -f "$original_file" ]; then
              # è®°å½•å°ºå¯¸ä¿¡æ¯
              dimensions="${file_dimensions[$original_file]}"
              dir_path=$(dirname "$original_file")
              base_name=$(basename "$original_file" | sed 's/\.[^.]*$//')
              yaml_file="$dir_path/.image_dimensions.yaml"
              touch "$yaml_file"
              if grep -q "${base_name}:" "$yaml_file" 2>/dev/null; then
                sed -i "s|${base_name}:.*|${base_name}: ${dimensions}|" "$yaml_file"
              else
                echo "${base_name}: ${dimensions}" >> "$yaml_file"
              fi
            
              rm "$original_file"
              echo "  - Removed: $(basename "$original_file")"
            fi
          done

      - name: 'ğŸš€ Commit and Push Changes'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: 'build(media): Convert images to multi-size AVIF'
          commit_author: ${{ github.actor }} <${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com>
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 'ğŸ”„ Force Push if Needed'
        if: failure()
        run: |
          git config --global user.name 'GitHub Actions Bot'
          git config --global user.email 'actions@github.com'
          git add -A
          if git commit -m "build(media): Convert images to multi-size AVIF [force]"; then
            git pull --rebase
